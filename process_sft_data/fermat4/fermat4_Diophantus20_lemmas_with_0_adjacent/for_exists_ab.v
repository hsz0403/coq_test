Require Export Descent.
Require Export Pythagorean.

Lemma for_exists_ab : forall u v m n : Z, v <= u -> u * u = m * m + n * n -> v * v = n * n - m * m -> 1 < u -> 1 < v -> Zodd v -> Zodd u -> rel_prime u v -> exists two : Z * Z, let (a, b) := two in (u - v = 4 * (a * a) /\ u + v = 2 * (b * b) \/ u - v = 2 * (b * b) /\ u + v = 4 * (a * a)) /\ 0 < a /\ 0 < b.
Proof.
intros u v m n Huv H H0 H1 H2 H3 H4 H5; elim (multiple4_2 u v H3 H4 Huv H5 H1 H2); intro; elim x; intros; elim_hyps; (cut (is_sqr (a * b)); [ intro Hab; elim (prop4 a b (Zlt_le_weak 0 a H7) (Zlt_le_weak 0 b H8) H9 Hab); intros; elim H11; intros Ha H11'; elim H11'; clear H11'; intros a0 H11'; elim H11'; clear H11'; intros H11' Ha0; elim H12; intros Hb H12'; elim H12'; clear H12'; intros b0 H12'; elim H12'; clear H12'; intros H12' Hb0; split with (a0,b0); intuition; [ rewrite <- H11' in H7; generalize (sqr_poss a0 H7); intro; auto with zarith | rewrite <- H12' in H8; generalize (sqr_poss b0 H8); intro; auto with zarith ] | apply (is_sqr_compat 2); try discriminate; replace (2 * 2 * (a * b)) with (m * m); [ apply is_sqr_sqr | apply (Zmult_eq_reg_l 2); try discriminate; replace (2 * (m * m)) with ((u * u) - (v * v)); [ replace (u * u - v * v) with ((u - v) * (u + v)); [ rewrite H6; rewrite H10; ring | ring ] | replace (2 * (m * m)) with ((m * m + n * n) - (n * n - m * m)); [ rewrite H; rewrite H0; ring | ring ] ] ] ]).
